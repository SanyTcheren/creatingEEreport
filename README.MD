# creatingEEreport
>Creating a report on the consumption of electrical energy when drilling oil wells

## Описание
> **Задача:** сгенерировать отчет по потреблению электрической энергии на кустовой площадке при бурении нефтяных скважин.
### Исходные данные
- Использование предпологается для множества буровых бригад, различающихся:
	- месторождением (м-е)
	- номером кустовой площадки (кп)
	- типом буровой установки (БУ)
	- зав. № БУ
- Контроль за потреблением электрической энергии осуществляется счетчиком электрической энергии СЭТ-4М, с которого в конце месяца снимается профиль мощности, который может быть как часовой, так и получасовой. Помимо него можно снять отчет потребления электрической энергии за месяц. Файлы имеют текстовый формат с кодировкой win-1251.  
- В течении месяца может бурится несколько скважин, время начала и оканчания может иметь дискретность до получаса. Промежуток времени между началом бурения одной скважины и окончанием предыдущей как правило относится к ПЗР следующей скважины
- Сгенерированный отчет должен соответствовать образцу формата Exel, в нем должна быть предусмотрена возможность корректировки полученных данных.
### Проект
> Пользователь снимает данные со  своего счетчика, загружает на сервер и получает сгенерировнный отчет. Для этого необходимо реализовать:
- регистраци на сервере
	- регистрация по email и паролю
- авторизация на сервере
	- авторизация с помощью jwt
- загрузку файлов на сервер
	- прямая загрузка данных
- валидацию исходных данных
	- проверка профиля мощности 
	- проверка отчета
	- проверка данных по скважинам
	- проверка дат
- передачу дополнительных данных о кп
	- передадим как объект json
- генерацию отчета
	- из загруженного профиля мощности
	- используем power-report-cli
- проверку отчета
	- сверить результат суммы по часам с итоговым отчетом за месяц
- передачу очета пользователю
	- прямая выгрузка файла
	- отправка на email
### Детали реализации
> Пишем на typescript для nodejs
- Сервер пишем на express
- Для бд используем sqlite и Prisma
- тесты реализуем на jest и supertest
- для фронтенда используем `ejs`
- будем реализовывать инверсию контроля над зависемостями с помощью `inversify`
- логирование будем осуществлять `tslog`, сообщения будем выводить в консоль и во всплывающих сообщениях приложения.
- будем отлавливать ошибки с помощью фильтров
- для конфигурации приложения будем использовать переменные среды (храненим соль при кодировании, секрет для jwt токена и номер запускаемого порта (возможно потом уберу)). Используем пакет `dotenv`
- для роутинга внутри приложения будем использовать Router express, реализуем через абстрактный контроллер, который будем наследовать в других контроллерах. Сразу заложим в него средний слой для локального уровня.
- для расшифровки переданных данных от формы будем использовать `import { urlencoded } from 'body-parser'` добавим его в наше апп на миддлвар
- для загрузки файлов на сервер будем использовать `import fileUpload from 'express-fileupload'` добавим его в наше апп на миддлвар
- для стилизации приложения используем `mustard-ui`
- будем использовть две структуры для проекта: `user` - для работы с пользовтелем и `report` - для работы с отчетом
- для валидации данных будем использовать `class-validator` и `class-transformer`


---
## Хронология
*2022-01-31* 

*Установка и настройка среды разработки*
1. С помощью git создан репозиторий для проекта, настроил ssh подключение, и через него подключился к удаленному репозиторию на GitHub.
2. Инициализирован проект `npm init`
3. Инициализирован typescript `tsc --init`
4. Установлен фреймворк `express` и импортированны типы его данных для TS. Для отладки рабочей среды написан простейший сервер.
5. Установлен `nodemon` и `ts-node`, создан файл в корне проекта `nodemon.json` настроен запуск в режиме отладки с автоматическим перезпуском ноды при изменениях в проекте. 
6. Установлены и сконфигурированы `ESLint`, `TS-ESLint`, `Prettier`, созданы конфигурационные файлы в корне проекта `.prettierrc`, прописал автоматическое исправление при сохранение файлов в `/.vscode/settings.json`, создал команды для проверки и исправления  
7. Настроен режим дебага для TS - в `tsconfig.json` установлено маппинг "sourceMap": true, и конфигурация  лаунчера `/.vscode/launch.json` для запуска ноды.
8. Настроен запуск для `Node Debugger` из инструментов разработчика  chrome - `dev:inspect`
9. Установлен и настроен Clinic Doctor вместе с autocannon для проверки и тестирования производительности, для запуска: `npm run doctor`
10. Подключен и настроен `jest` для unit-test, создан `jest.config.ts`, запуск `npm run test` 
11. Подключен и настроен `supertest` для e2e-test, создан `jest.e2e.config.ts` и директория `tests`, запуск - `test:e2e`
12. Подключена `Prisma` и её клиент, выполнена первичная инициализация - `npx prisma init`, настроен провайдер и подключение к бд, cоздана модель таблицы - `./prisma/schema.prisma`. Выполнена миграция данныx - `npx prisma migrate dev` с именем init. Добавлены исключения  в `.gitignore`. Подчищен файл `.env`. Выполнена генерация типов - `npm run generate` 

*2022-02-01*

*Создание и опробование простого фронтенда*
1. В качестве "рыбы" использовал этот [сайт](https://www.npmjs.com/package/ejs)
2. Будем использовать [ejs](https://www.npmjs.com/package/ejs)
3. Статические ресурсы подключены к папке `/public`
4. Создана стандартная папка `views` для размещения файлов `ejs`
5. Набросана приблизительная структура сайта `Login -> [Register] -> Input -> Report`
6. Созданы всплывающие сообщения [пример](https://html5css.ru/howto/howto_js_alert.php)
7. Настроено копирование папки public  - `"build": "tsc | cp -r ./public ./dist/public",`

*Реализация инверсии контроля управления над зависемостями*
1. Устанавливаем `inversify`
2. Создаем файл с токенами для идентификации инстансов нащих классов - `types.ts`
3. Точкой сборки проекта будет - `main.ts`, в нём реализуем функцию первичной инициализации приложения, которая будет:
	- создавать контейнер, 
	- биндить в него наши инстансы, 
	- брать инстанс приложения и инициировать его
	- возвращать интерфейс, включающий приложение и контейнер
	- экспортировать само приложение и контейнер,
4. Создаем класс нашего приложения, он будет:
	- `@injectable()` - передаваться в контейнер
	- `import 'reflect-metadata';` - в него будут инжектироваться другие инстансы из контейнера
	- будет содержать поле `app: Express` иницилизируемое в конструкторе
	- содержать метод `init()` - инициализирующий наше приложение:
		- подключать обработчики запросов
		- подключаься к базе данных (реализуем позже)
		- запускать сервер и слушать его
	- содержать метод `close()` закрывающий сервер при выходе из приложения
5. Организуем сленое архитектуру нашего приложения, для создадим и последовательно вызовем в `init()` следующие методыЖ
	- `useMiddleware(): void` - подключение глобальных промежуточных обработчиков
	- `useRoutes(): void` - подключение роутеров
	- `useExceptionFilters(): void` - подключение фильтра исклчений

*Подключение логгера*
1. Создаем интерфейс логгера со стандартными методами
2. Создаем реализацию логгера на основе `tslog`
3. Создали токен в TYPES и положили реализацию в наш контейнер
4. Достали реализацию в конструктоере приложения и использовали для логирования (`import 'reflect-metadata';` - обязательно для правильной работы декораторов)

*создание фильтра исключений*
1. Создаем собственный класс ошибок `HttpError`
2. Создаем интерфейс фильтра с методом `catch`
3. Создадим реализацию фильтра в котором будем устанавливать статус ответа, передавать ошибку и логировать (инжектируем логер в конструкторе), нашу ошибку будем обрабатывать отдельно. Не забываем (`import 'reflect-metadata';`)
4. Добавляем в контейнер инстанс фильтра,  добавляем в наше приложение и вызываем в методе `useExceptionFilters(): void` где необходимо его забиндить чтобы не потерять контекст. 
5. Пока просто передаем дальше объект с ошибкой

*Конфигурация приложения*
1. Создадим интерфейс конфигурации с одним методом `get`
2. Создадим класс сервиса конфигурации берущего настройки приложения из переменных среды (хранятся в `.env` файле, или указываются при запуске ноды)
3. Используем `config` из `dotenv`, проверяем результат на ошибку, логируем и реализуем метод `get`.
4. Добавляем сервис в контейнер  и используем его для назначения порта, потом будем брать из него секрет для токена и соль для шифрования.

*2022-02-02*

*Роутинг приложения*
1. Создадим абстрактный контроллер для роутинга,который:
	- в конструкторе будет принимать логгер, 
	- создавать приватное свойство только для чтения _router со своим геттером из Router express
	- содержать метод бинда роутов,
2. Создадим интерфейс для описания роутов - `IRouteApp`, содержащий:
	- путь, по кторому будем переходить
	- методы, которые будем использовать, определим для них тип с помощью ключей утилитарного класса [Pick express](https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys), это даст нам применяемые в express типы для стандартных методов http-запросов  
	- функцию для перехода по указанному пути
	- необязательный параметр локального среднего слоя с типом определяемым в отдельном интерфейсе `IMiddleWare` содержащий метод `execute` (создадим его в отдельном файле)
3. Добавим в абстрактный контроллер `bindRoutes` который
	- логгирует подключаемые роуты
	- проверит и забиндит средний уровень
	- забиндит контекст роутов 
	- использует pipline для добавления в роутер
4. Создадим в абстрактом контроллере вспомогательные методы - `created`, `send`, `ok`, которые для удобства будут возвращать спецальный тип `ExpressReturnType` опишем и экспортируем его из `IRouteApp`
5. Создадим интерфейс контроллера юзера, который будет содержать метода логина, регистрации и индормирования о текущем профиле, исх. данных, отчета,...
6. Создадим контроллер юзера расширяющий абстрактный контроллер и реализующий интерфейс
	- будем инжектить его - поэтому `import 'reflect-metadata';`
	- в конструктор передадим логгер 
	- в конструкторе вызовем метод `bindRoutes` и передадим в него наши роуты
	- реализуем интерфейс и используем функции при передаче роутов в конструкторе
7. Добавляем контроллер в коробку, достаем его в нашем приложении и используем в методе `useRoutes`
8. Рисуем примерную структуру приложения и реализуем роутинг в контроллере юзера.

*2022-02-03*

*Стилизация приложения*
1. Устанваливаем `mustard-ui`
2. Добавляем в `head` - `<link rel="stylesheet" href="https://unpkg.com/mustard-ui@latest/dist/css/mustard-ui.min.css">`
3. Cтилизовал под установленные стили, добавил вступительную страницу
4. Добавил поле сообщений, будем передавать в него через `res.render('pages/report', { message: 'you register success!!!' })`

*Разделение сущностей на user & report*
1. Cоздадим конструкт `report` и перенесем в его контроллер роуты для создания отчета
2. Регистрируем `report.controller` и биндим его роутер
3. Добавим валидацию данных, для этого создадим `ValidateMiddleware` в конструктор которого будем передавать класс валидируемого объекта. Будем добавлять его на локальный средний уровень и валидировать в нем наши dto. В случае если валидация не успешна добавляем к телу свойство `unvalidate` куда будем ложить первую причину неудачи.
4. Создадим dto для каждого роута и провалидируем их
5. В методах роутов проверим на прохождение валидации и при необходимости попросим исправить данные, для этого создадим вспомогательный метод в бстрактном контроллере `unvalidateRender`.







---
## Средства разработки
- `vscode` - редактор кода. 
- `git` - система управления версиями, удаленный репозиторий на github.com
- `npm` для управления зависемостями
- `typescript` - язык нашего приложения 
- `express` - для обработки сетевых запросов
- `nodemon` - для запуска в режиме отладки
- `ts-node` - для запуски в ноде TS
- `eslint`, `prettier` - для линта и форматирования кода
- `clinic` - для проверки производительности приложения (установлен глобально)
- `autocannon` - для создани нагрузки на приложение (установлен глобально)
- `jest` - для юнит тестов
- `supertest` - для е2е тестов
- `prisma` - для работы с базой данных
- `ejs` - для фронтенда
- `inversify` - для инверсии контроля над зависемостями
- `reflect-metadata` - для использования декораторов
- `tslog` - для логирования
- `dotenv` - для работы с переменными среды
- `body-parser` - для парсинга тела запроса при передачи данных от формы
- `express-fileupload` - для загрузки файлов на сервер
- `mustard-ui` - стилизация приложения
- `class-validator` - позволяет использовать декораторы валидации данных
- `class-transfomer` - позволит создавать корректные dto


## Установленные пакеты
```
npm i express
npm i -D @types/express
npm i -D nodemon ts-node
npm i -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
npm i -D prettier eslint-config-prettier eslint-plugin-prettier
npm i -D typescript  //Нужен для линтера
npm i -D jest ts-jest @types/jest 
npm i -D supertest @types/supertest
npm i -D prisma
npm i @prisma/client  //Клиент призмы
npm i ejs @types/ejs
npm i inversify
npm i reflect-metadata
npm i tslog
npm i dotenv
npm i body-parser
npm i express-fileupload
npm i --save-dev @types/express-fileupload
npm install mustard-ui
npm i class-validator
npm i class-transformer
```

## Настройка npm (packege.json)
- `"version": "0.0.0"` - мажорная версия 0 означает что приложение пока не работает
- `"type": "commonjs"` - будем использовать максимально поддерживаемые модули
- `"start": "node ./dist/main.js",` запускать будем нодой
- `"build": "tsc",` собирать будем компилятором TS
- `"test": "jest"` тестировать будем jest
- `"dev": "nodemon"` режим отладки
- ` "lint": "selint ./src**"` - линт кода
- `"lint:fix":"eslint ./src/** --fix"` - форматировние кода
- `"doctor": "clinic doctor --on-port 'autocannon -m GET localhost:8000/hello' -- node dist/main.js"` - запуск Clinic doctor
- `"test:e2e": "jest --config jest.e2e.config.ts --coverage"` - запуск е2е тестов с анализом покрытия кода
- `"generate": "npx prisma generate"` генерация типов из базы данных


-
## Настройка TS (typescript.json)
- `"experimentalDecorators": true` - включил поддержку декораторов, понадобятся для инверсии зависемостей
- `"emitDecoratorMetadata": true,` - поддержка метаданных
- `"moduleResolution": "node"` - интерпритатор для модулей
- `"outDir": "./dist"` - папка для сборки проекта
- `"removeComments": true,`- при сборке удаляем комменты

## Настройка .gitignore
- `/node_modules` - модули всегда можно скачать
- `/dist` - эти файлы создаются при билде проекта
- `/.clinic` - файлы отчета клиник доктора
- `/prisma/dev.db` `/prisma/dev.db-journal` - данные призмы
- `/.env` - переменные окружения